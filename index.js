'use strict';

var fs = require('fs');
var process = require('process');

const platforms = {};

module.exports = function (app) {
    const detectedPlatform = module.exports.detect();
    if (!detectedPlatform) {
        throw new Error('No supported platform detected.');
    }
    detectedPlatform.serve(app);
};

module.exports.detect = function () {
    const platformsByPriority = {};
    for (let platformName in platforms) {
        const platform = platforms[platformName];
        const samePriorityPlatforms = platformsByPriority[platform.priority] = platformsByPriority[platform.priority] || [];
        samePriorityPlatforms.push(platform);
    }
    const prioritysList = [];
    for (let i in platformsByPriority) {
        prioritysList.push(platformsByPriority[i][0].priority);
    }
    // sort() is not numerical by default. Note we sort descending so
    // high priority values get visited first.
    prioritysList.sort((a, b) => b - a);

    for (let priority of prioritysList) {
        const samePriorityPlatforms = platformsByPriority[priority];
        const detectedPlatforms = [];
        for (let platform of samePriorityPlatforms) {
            if (platform.detect()) {
                detectedPlatforms.push(platform);
            }
        }
        if (detectedPlatforms.length) {
            if (detectedPlatforms.length > 1) {
                const detectedPlatformsString = detectedPlatforms.reduce(function (s, platform) {
                    if (s) {
                        s += ', ';
                    }
                    return s + platform.name;
                }, '');
                throw new Error(`Multiple platforms at priority ${priority} were detected. Only one platform may be detected for any given priority. Please adjust prioritys or fix false positives. Platforms: ${detectedPlatformsString}`);
            }
            // Produce the polished “platform” which sets
            // request.baseUrl. This might cause confusion because
            // detect() returns a “platform” that behaves differently
            // from the “platform” you would register via register()…
            const detectedPlatform = detectedPlatforms[0];
            const detectedPlatformServe = detectedPlatform.serve;
            return Object.assign({}, detectedPlatform, {
                serve: function (app) {
                    detectedPlatformServe.call(this, function (req, res) {
                        if (!req.baseUrl) {
                            req.baseUrl = detectedPlatform.getBaseUrl(req);
                        }
                        return app(req, res);
                    }, module.exports.options[detectedPlatform.name] || {});
                },
            });
        }
    }
};


// Extends options by module. For each module, the keys shall be
// shallowly merged. I guess that makes this like a 1-level-deep
// merge. Not named setOptiosn() because that would imply that it
// clears out existing options when it doesn’t.
module.exports.extendOptions = function (options) {
    for (let platformName in options) {
        let target = module.exports.options[platformName] = module.exports.options[platformName] || {};
        Object.assign(target, options[platformName]);
    }
};

// Per-platform options keyed by platform.name. The options for the
// detected platform or an empty object will be passed to
// platform.serve() as a second argument when serve() is called.  This
// is provided so that app wrapping scripts, such as ones generated by
// deployment scripts, can set up custom platforms and options on it
// before launching an autoserve-supporting app. It is probably easier
// to use the extendOptions() API.
module.exports.options = {};

// Convenience to override particular properties of a registered
// platform.
module.exports.override = function (platformName, obj) {
    const platform = module.exports.platforms[platformName];
    if (!platform) {
        throw new Error(`Platform ${platformName} is not registered. Thus, it cannot be overridden.`);
    }
    return module.exports.register(Object.assign({}, platform, obj));
};

module.exports.platforms = Object.freeze(Object.create(platforms));

// Register a platform. Registered platforms are stored in the
// platforms property. To make changes to a registered platform,
// reregister it or call the override() convenience function. When a
// platform is registered, it is validated and a frozen shallow copy
// is stored in the registry. Thus, platform implementations must be
// able to operate even after such a copy.
module.exports.register = function (platform) {
    platform = Object.freeze(Object.assign({
        getBaseUrl: function () {
            return '/';
        },
        priority: 0,
    }, platform));

    if (!platform.name) {
        throw new Error('Platform is missing name.');
    }

    if ((platform.priority|0) !== platform.priority) {
        throw new Error(`Platform ${platform.name} priority “${platform.priority}”is not an integer.`);
    }

    for (let requiredFunction of [
        'detect',
        'serve',
    ]) {
        if (typeof platform[requiredFunction] !== 'function') {
            throw new Error(`Platform ${platform.name} is missing ${requiredFunction}().`);
        }
    }
    platforms[platform.name] = platform;
};

module.exports.serve = module.exports;

Object.freeze(module.exports);

// Register core/built-in platforms.
for (let platformName of [
    'http',
    'passenger',
]) {
    module.exports.register(require(`./platform/${platformName}`));
}
for (let platformModuleName of [
    'autoserve-platform-node-fastcgi',
]) {
    // Conditionally require() to support optional dependencies.
    // http://stackoverflow.com/a/21740407/429091
    let platform;
    try {
        platform = require(platformModuleName);
    } catch (ex) {
    }
    if (platform) {
        module.exports.register(platform);
    }
}
